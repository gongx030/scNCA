% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scNCA.r
\name{scNCA}
\alias{scNCA}
\title{scNCA}
\usage{
scNCA(x, K = 5, batch = NULL, time.table = NULL, max.iter = 5000,
  p0 = 0.2, learning_rate = 0.01)
}
\arguments{
\item{x}{a gene expression matrix (normalized and scaled)}

\item{K}{number of low dimensions}

\item{batch}{a numeric vector indicating the batch labels of each cell}

\item{time.table}{a binary matrix indicating the distribution of cells at each time point}

\item{max.iter}{maximum iterations (default: 5000)}

\item{p0}{cutoff for context likelihood neighbors (default: 0.2)}

\item{learning_rate}{learing rate for AdaGrad (default: 0.01)}
}
\value{
a list of scNCA results.
}
\description{
aaaaa Integrating multiple sources of temporal scRNA-seq data by neighborhood component analysis
}
\examples{
library(scNCA)
# Let us first simulate a balanced temporal scRNA-seq data with 2,000 genes, three lineages, 
# three batches and five time points. In the balanced data, each batch covers the cells from all lineages and time points. 
# We assume that there are 100 cells for each lineage/batch combination so there are in total 900 cells:
ncells <- cbind(
	c(100, 100, 100),   # batch i
 c(100, 100, 100),   # batch ii
 c(100, 100, 100)    # batch iii
)
time.points <- cbind(
	c(1, 1, 1, 1, 1),   # batch i
	c(1, 1, 1, 1, 1),   # batch ii
	c(1, 1, 1, 1, 1)    # batch iii
)
set.seed(1)
se <- simulateTemporalRNAseq(ncells = ncells, time.points = time.points)

X <- assays(se)$counts	# the simulated scRNA-seq expression matrix
X <- as.matrix(X \%*\% Diagonal(x = 1 / sqrt(colSums(X^2))))	# consine scaling

set.seed(1)
mf <- scNCA(X, batch = colData(se)$batch, time.table = colData(se)$time.table)

# set up the color and shape of the plot
n2bg <- c(
 '1_1' = 'red', '1_2' = 'lightblue', '1_3' = 'green',  # batch i
 '2_1' = 'red', '2_2' = 'lightblue', '2_3' = 'green',  # batch ii
 '3_1' = 'black', '3_2' = 'black', '3_3' = 'black'     # batch iii
)
n2pch <- c(
 '1_1' = 21, '1_2' = 21, '1_3' = 21, # batch i
 '2_1' = 24, '2_2' = 24, '2_3' = 24, # batch ii
 '3_1' = 3, '3_2' = 3, '3_3' = 3     # batch iii
)
n2col <- c(
 '1_1' = 'black', '1_2' = 'black', '1_3' = 'black',  # batch i
 '2_1' = 'black', '2_2' = 'black', '2_3' = 'black',  # batch ii
 '3_1' = 'red', '3_2' = 'lightblue', '3_3' = 'green' # batch iii
)
bg <- n2bg[colData(se)$cell_label]
pch <- n2pch[colData(se)$cell_label]
col2 <- n2col[colData(se)$cell_label]

library(DDRTree)
dt <- DDRTree(mf$Y, verbose = TRUE, sigma = 1e-3, maxIter = 5)
y <- t(dt$Z)
plot(y[, 1], y[, 2], bg = bg, pch = pch, col = col2, cex = 1.5, xaxt = 'n', yaxt = 'n', xlab = '', ylab = '')

}
\author{
Wuming Gong
}
